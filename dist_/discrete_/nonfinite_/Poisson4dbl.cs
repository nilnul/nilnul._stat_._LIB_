using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using R = nilnul.num.RealI;
using Positive = nilnul.num.real.be_.positive.vow.En;
using nilnul.num.real;
using nilnul.num;

using N = nilnul.Num1;
using nilnul.stat._dist_;
using System.Numerics;
using nilnul.collection.family_.field_.sigmable_;

namespace nilnul.stat.dist_.discrete_.nonfinite_
{

	/// <summary>
	/// how many people come in  when the time is in the interval of [0,t)
	/// </summary>
	public  class Poisson4dbl
		:
		dist_.discrete_.Nonfinite4dblI<uint>
	{
		private nilnul.num.real_.PositiveDbl _lambda;

		public nilnul.num.real_.PositiveDbl lambda
		{
			get { return _lambda; }
			set { _lambda = value; }
		}
		
		public Poisson4dbl(nilnul.num.real_.PositiveDbl lambda)
		{
		
			this._lambda = lambda;

		}
		public Poisson4dbl(double x):this(new num.real_.PositiveDbl(x))
		{
			
		}

		

		public double pmf(uint sample)
		{
			return Math.Pow(_lambda.ee, sample) * Math.Exp(
				-this.lambda
			) / (ulong)  nilnul.num.op_._FactorialX._Eval_byLoop(sample); /// if sample is too large, this might throw overflow;
		}

		public double[] mode {
			get {

				/// ##The mode of a Poisson-distributed random variable with non-integer λ is equal to \scriptstyle\lfloor \lambda \rfloor, which is the largest integer less than or equal to λ. This is also written as floor(λ). When λ is a positive integer, the modes are λ and λ − 1.

				var i = Math.Floor(_lambda);

				var ceil = Math.Ceiling(_lambda);
				var ceilDec = ceil - 1;
				if (ceilDec == i)  
				{
					return new[] { ceilDec};
				}// lambda is not int;
				// lambda is  int;
				return new[] {ceilDec ,i};

				//throw new NotImplementedException();
			}
		}

		public double mean {
			get {
				return _lambda;
			}
		}

		public double variance {
			get {
				return lambda;
			}
		}


		/** 
		 * Ben (https://stats.stackexchange.com/users/173082/ben), Relationship between poisson and exponential distribution, URL (version: 2020-05-27): https://stats.stackexchange.com/q/468761
		 * 
		 * A Poisson random variable with parameter λ>0 can be generated by counting the number of sequential events occurring in time λ/η, where the times between the events are independent exponential random variables with rate η. (Setting η=1 gives you a simple way to generate a Poisson random variable from a series of IID unit exponential random variables.)
		  

This means that if E1,E2,E3,...∼Exp(η) with rate parameter η>0, and K∼Pois(λ) with rate parameter λ>0 then you have:

P(K⩾k)=P(E1+⋯+Ek⩽λ/η).
		
		 */


		///
		/// <summary>
		/// 
		/// </summary>
		/// <returns></returns>
		public uint sample() {

			/*en.wikipedia.org/wiki/Poisson_distribution 
			 * by knuth.

			algorithm poisson random number (Knuth):
init:
	 Let L ← e−λ, k ← 0 and p ← 1.
do:
	 k ← k + 1.
	 Generate uniform random number u in [0,1] and let p ← p × u.
while p > L.
return k − 1.
			*/

			/// slice the timespan such each slice lengthed with an excpected occurence as 1;
			var L = Math.Exp( - _lambda);  // possibility for none;  // in the specified period, no person would come at a probability;  P( next2come < 1) = 1-L;
			var k = 0u;
			var remainedTime = 1d;
			do
			{
				k++;

				///for shrinked time, the lambd for exp distribution shall be shrinked as well;
				///
				var remainedTimeFraction=nilnul.stat.dist_.borel_.pdf_.uniform_._Preportion4dblX.Sample();  // some person come;
				remainedTime *= remainedTimeFraction;  //  for shrinked remained time;
				/*
				 If for every t > 0 the number of arrivals in the time interval [0, t] follows the Poisson distribution with mean λt, then the sequence of inter-arrival times are independent and identically distributed exponential random variables having mean 1/λ
				 *****/

			} while (remainedTime>L);    /// p &le; L: none would come;   p>L: next person would come; 
			return k - 1;

		}


	}
}
