using nilnul.num.rational;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using nilnul.prob.discrete;
using nilnul.prob.rationalMeasure.rationalSample;
using nilnul.prob.rationalProb;
using nilnul.prob.rationalProb.rationalSample;

namespace nilnul.prob.rationalMeasure.empirical
{
	/// <summary>
	/// 
	/// </summary>
	public partial class EmpiricalDistribution
	{

		/// <summary>
		/// generated by empirical such that: 
		/// 
		/// sample of zero probability is removed. 
		/// 
		/// probability of each sample is assigned 1/(n+1)
		/// 
		/// prepend a sample of probabilit 0 at offset -(max-min)/(n-1) to the first sample.
		/// 
		/// appenda a sample of probability 1 at offset to the last sample of max-min/(n-1)
		/// 
		/// 
		/// </summary>
		///<remarks>
		/// or make it symetric in both diections.
		///  let the samples each of the probability of 1/(n+1).
		///  and append a sample of 1/(n+1) to the last sample with offset of length/(n-1)/2
		///  
		/// this will make the increase of decrease of probability among samples from each direction to be symmetric.
		/// or there is a gap of 1/(n+1) between these (n+2) points. the 2 points plused should be prepended or appended at half the gap.
		/// 
		/// this should start at the density at the beginning.
		/// 
		/// and the ending cdf will begin with a sample point of 0 probability. (0,0) (x1,1/(n+1)), ( 1/(n+2)), (xn+1, 1)
		/// </remarks> 

		//public FiniteCdf_rational2 cdf;


		//public EmpiricalDistribution(FiniteCdf_rational2 cdf)
		//{
		//	this.cdf = cdf;
		//}


		//public PositiveSample_NotEmptyCollection samples;

		public NonEmptyCollectionOfPositiveSample samples;


		public List<Event> cumulativeSequence;

		public Cdf cdf;

		public List<Event> sampleProbCollection;

		public Rational_InheritFraction density(Rational_InheritFraction sample)
		{


			//find the interval.



			var interval = nilnul.interval.BinarySearchX.BinarySearchX_ListBiSearch_index<Rational_InheritFraction>(
					(sample),
					sampleProbCollection.Select(c => c.probabilityNotNull).Cast<Rational_InheritFraction>().ToList(),
					nilnul.num.rational.order.Comparer.Instance
			);



			if (interval.Item2== null)
			{
				return Prob.Zero;

			}

			if (interval.Item1== null)
			{
				return Prob.Zero;

			}


			return sampleProbCollection[interval.Item2.Value].probability.val as Rational_InheritFraction / ( sampleProbCollection[interval.Item2.Value].sample-sampleProbCollection[interval.Item1.Value].sample);






			throw new NotImplementedException();



		}


		public List<SampleCount> GenerateDensityFunc(PositiveSample_NotEmptyCollection samples)
		{
			//prepend a sample offset -1/(n+1)/2 of probability 0
			//prepend a sample offset 1/(n+1)/2 of probability 1/(n+1).
			//due to the characteristics of CDF, this will make the CDF-generated PMF distribution to be:
			///( 1/(n+1), 1/(n+1),...,1/(n+1),1/(n+1))
			///

			//append a sample



			var count = samples.count;
			var max = samples.Aggregate(samples.First(), (a, c) => c.sample.val > a.sample.val ? c : a).count.val;
			var min = samples.Aggregate(samples.First(), (a, c) => c.count.val > a.count.val ? c : a).count.val;

			var probSpan = nilnul.num.rational.Rational_InheritFraction.Divide(1, (count + 1));


			var len = max - min;
			var span = nilnul.num.rational.Rational_InheritFraction.Divide(len, (count - 1));




			var sample = nilnul.num.rational.Rational_InheritFraction.Divide(1, len) + max;


			var prepend = min - span;



			var result = new List<rationalSample.SampleCount>();
			result.Add(new SampleCount(prepend, 0));

			//todo: add all

			result.Add(new SampleCount(sample, 1));




			samples.Add(
				new SampleCountPositive(
					sample
					,
					1

				)
			);

			return result;


		}

		public List<SampleCount> GenFrequency(PositiveSample_NotEmptyCollection samples_countPlural)
		{
			//prepend a sample offset -1/(n+1)/2 of probability 0
			//prepend a sample offset 1/(n+1)/2 of probability 1/(n+1).
			//due to the characteristics of CDF, this will make the CDF-generated PMF distribution to be:
			///( 1/(n+1), 1/(n+1),...,1/(n+1),1/(n+1))
			///

			//append a sample

			var count = samples_countPlural.count;
			var maxSample = samples_countPlural.Aggregate(samples_countPlural.First(), (a, c) => c.sample.val > a.sample.val ? c : a).sample.val;
			var minSample = samples_countPlural.Aggregate(samples_countPlural.First(), (a, c) => c.count.val > a.count.val ? c : a).count.val;

			var probSpan = nilnul.num.rational.Rational_InheritFraction.Divide(1, (count + 1));


			var len = maxSample - minSample;
			var span = nilnul.num.rational.Rational_InheritFraction.Divide(len, (count - 1));




			var sample = nilnul.num.rational.Rational_InheritFraction.Divide(1, len) + maxSample;


			var prepend = minSample - span;



			var result = new List<rationalSample.SampleCount>();

			var result2 = new List<rationalProb.rationalSample.Event>();


			result.Add(new SampleCount(prepend, 0));

			//todo: add all

			result.Add(new SampleCount(sample, 1));




			samples_countPlural.Add(
				new SampleCountPositive(
					sample
					,
					1

				)
			);

			return result;


		}
		public List<SampleCount> GenFrequency(NonEmptyCollectionOfPositiveSample samples_countPlural)
		{
			//prepend a sample offset -1/(n+1)/2 of probability 0
			//prepend a sample offset 1/(n+1)/2 of probability 1/(n+1).
			//due to the characteristics of CDF, this will make the CDF-generated PMF distribution to be:
			///( 1/(n+1), 1/(n+1),...,1/(n+1),1/(n+1))
			///

			//append a sample

			var count = samples_countPlural.count;
			var maxSample = samples_countPlural.Aggregate(samples_countPlural.First(), (a, c) => c.sample.val > a.sample.val ? c : a).sample.val;
			var minSample = samples_countPlural.Aggregate(samples_countPlural.First(), (a, c) => c.count.val > a.count.val ? c : a).count.val;

			var probSpan = nilnul.num.rational.Rational_InheritFraction.Divide(1, (count + 1));


			var len = maxSample - minSample;
			var span = nilnul.num.rational.Rational_InheritFraction.Divide(len, (count - 1));




			var sample = nilnul.num.rational.Rational_InheritFraction.Divide(1, len) + maxSample;


			var prepend = minSample - span;



			var result = new List<rationalSample.SampleCount>();

			var result2 = new List<rationalProb.rationalSample.Event>();


			result.Add(new SampleCount(prepend, 0));

			//todo: add all

			result.Add(new SampleCount(sample, 1));




			samples_countPlural.Add(
				new SampleCountPositive(
					sample
					,
					1

				)
			);

			return result;


		}


		public List<Event> GenDensityFunc3(
			PositiveSample_NotEmptyCollection samples_countPlural
			)
		{

			var freq = GenFrequency(samples_countPlural);

			var count = samples_countPlural.count;

			var result = new List<Event>();

			result.AddRange(
				freq.Select(c => new Event(
					c.sample.val,

					nilnul.num.rational.Rational_InheritFraction.Divide(c.count.val, count
					)))
			);


			return result;

			throw new NotImplementedException();


		}
		public List<Event> GenDensityFunc3(
				NonEmptyCollectionOfPositiveSample samples_countPlural
				)
		{

			var freq = GenFrequency(samples_countPlural);

			var count = samples_countPlural.count;

			var result = new List<Event>();

			result.AddRange(
				freq.Select(c => new Event(
					c.sample.val,

					nilnul.num.rational.Rational_InheritFraction.Divide(c.count.val, count
					)))
			);


			return result;

			throw new NotImplementedException();


		}

		public List<Event> GenCumulativeDensityFunc(
				PositiveSample_NotEmptyCollection samples_countPlural

		)
		{

			var densityFunc = GenDensityFunc3(samples_countPlural);
			var cumulativeDensity = Prob.Zero;

			for (int i = 1; i < densityFunc.Count(); i++)
			{

				densityFunc[i].probability = new Prob(densityFunc[i].probability.val + densityFunc[i - 1].probability.val);

			}

			return densityFunc;

			throw new NotImplementedException();

		}



		public List<Event> GenCumulativeDensityFunc(
			NonEmptyCollectionOfPositiveSample samples_countPlural

	)
		{

			var densityFunc = GenDensityFunc3(samples_countPlural);
			var cumulativeDensity = Prob.Zero;

			for (int i = 1; i < densityFunc.Count(); i++)
			{

				densityFunc[i].probability = new Prob(densityFunc[i].probability.val + densityFunc[i - 1].probability.val);

			}

			return densityFunc;

			throw new NotImplementedException();

		}







		//public ProbabilityInRational density(
		//	nilnul.num.rational.Rational_InheritFraction x
		//) { 




		//}



	}
}
